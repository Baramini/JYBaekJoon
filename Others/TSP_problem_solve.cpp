#include <iostream>

using namespace std;

/*
제가 선택한 방식은 클러스터링 기반의 휴리스틱 알고리즘입니다.
NP-Hard 문제이므로 다항식 시간안에 최적해를 구하는 것은 불가능하기 때문에
다항식 시간안에 해결이 되면서도 어느 정도의 근사비율을 보장하는 방식을 골랐습니다.

이 알고리즘에서는 총 3가지의 단계로 문제를 해결합니다.
1. 클러스터링을 통해 부분집합으로 나눕니다.
2. 각각의 부분집합에서 최적해를 구합니다.
3. 각 부분집합을 합치면서 최종 TSP의 근사해를 도출합니다.

구체적인 과정은 다음과 같습니다.
1번의 과정에서 K-means 알고리즘을 사용하여 여러 부분집합으로 클러스터링합니다.
2번의 과정에서 DP를 활용한 Bellman-Held-Karp 알고리즘을 사용하며 각 부분집합에서의 TSP의 최적해를 찾습니다.
3번의 과정에서 이웃하는 두 클러스터를 연결할 때 가장 짧은 경로를 찾아서 연결하도록 합니다.

해당 알고리즘의 가장 큰 장점은 3가지라고 생각했습니다.
1. 부분 집합의 최적해를 보장하기 때문에 어느 정도의 근사비율을 보장할 것이라 생각했습니다.
2. 노드의 개수가 많으면 많을수록 다른 알고리즘에 비해 시간을 많이 단축할 수 있을 것이라 생각했습니다.
3. 각 부분집합에서 최적해를 찾는 과정이 독립적이기 때문에 병렬적으로 처리할 수 있어서 시간을 단축할 수 있을 것이라 생각했습니다.
*/

int main() {
    return 0;
}